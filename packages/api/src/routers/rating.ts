import { getLogger } from "@orpc/experimental-pino";
import { and, desc, eq, sql } from "@repo/db";
import { post, postRating, user } from "@repo/db/schema/app";
import { ratingCreateSchema, ratingUpdateSchema } from "@repo/shared/schemas";
import z from "zod";
import {
  permissionProcedure,
  protectedProcedure,
  publicProcedure,
} from "../index";

export default {
  // Create or update a rating (upsert)
  create: protectedProcedure
    .input(ratingCreateSchema)
    .handler(async ({ context: { db, session, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(
        `User ${session.user.id} creating/updating rating for post ${input.postId}: ${input.rating} stars`
      );

      await db
        .insert(postRating)
        .values({
          postId: input.postId,
          userId: session.user.id,
          rating: input.rating,
          review: input.review ?? "",
        })
        .onConflictDoUpdate({
          target: [postRating.userId, postRating.postId],
          set: {
            rating: input.rating,
            review: input.review ?? "",
            updatedAt: new Date(),
          },
        });

      logger?.debug(
        `Rating upserted for user ${session.user.id} on post ${input.postId}`
      );
      return { success: true };
    }),

  // Update own rating
  update: protectedProcedure
    .input(ratingUpdateSchema)
    .handler(async ({ context: { db, session, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(
        `User ${session.user.id} updating rating for post ${input.postId}: ${input.rating} stars`
      );

      await db
        .update(postRating)
        .set({
          rating: input.rating,
          review: input.review ?? "",
          updatedAt: new Date(),
        })
        .where(
          and(
            eq(postRating.postId, input.postId),
            eq(postRating.userId, session.user.id)
          )
        );

      logger?.debug(
        `Rating updated for user ${session.user.id} on post ${input.postId}`
      );
      return { success: true };
    }),

  // Delete own rating
  delete: protectedProcedure
    .input(z.object({ postId: z.string() }))
    .handler(async ({ context: { db, session, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(
        `User ${session.user.id} deleting rating for post ${input.postId}`
      );

      await db
        .delete(postRating)
        .where(
          and(
            eq(postRating.postId, input.postId),
            eq(postRating.userId, session.user.id)
          )
        );

      logger?.debug(
        `Rating deleted for user ${session.user.id} on post ${input.postId}`
      );
      return { success: true };
    }),

  // Admin delete any rating
  deleteAny: permissionProcedure({ ratings: ["delete"] })
    .input(z.object({ postId: z.string(), userId: z.string() }))
    .handler(async ({ context: { db, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(
        `Admin deleting rating: user ${input.userId} on post ${input.postId}`
      );

      await db
        .delete(postRating)
        .where(
          and(
            eq(postRating.postId, input.postId),
            eq(postRating.userId, input.userId)
          )
        );

      logger?.debug(
        `Rating deleted by admin for user ${input.userId} on post ${input.postId}`
      );
      return { success: true };
    }),

  // Get all ratings for a post
  getByPostId: publicProcedure
    .input(z.object({ postId: z.string() }))
    .handler(async ({ context: { db, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(`Fetching all ratings for post: ${input.postId}`);

      const ratings = await db
        .select({
          postId: postRating.postId,
          userId: postRating.userId,
          rating: postRating.rating,
          review: postRating.review,
          createdAt: postRating.createdAt,
          updatedAt: postRating.updatedAt,
        })
        .from(postRating)
        .where(eq(postRating.postId, input.postId))
        .orderBy(desc(postRating.createdAt));

      const userIds = [...new Set(ratings.map((r) => r.userId))];

      const authors =
        userIds.length > 0
          ? await db
              .select({
                id: user.id,
                name: user.name,
                image: user.image,
                role: user.role,
              })
              .from(user)
              .where(
                sql`${user.id} IN (${sql.join(
                  userIds.map((id) => sql`${id}`),
                  sql`, `
                )})`
              )
          : [];

      logger?.debug(
        `Retrieved ${ratings.length} ratings with ${authors.length} unique authors for post ${input.postId}`
      );
      return { ratings, authors };
    }),

  // Get recent ratings across all posts (paginated)
  getRecent: publicProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(50).default(20),
        offset: z.number().min(0).default(0),
      })
    )
    .handler(async ({ context: { db, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(
        `Fetching recent ratings with limit: ${input.limit}, offset: ${input.offset}`
      );

      const ratings = await db
        .select({
          postId: postRating.postId,
          userId: postRating.userId,
          rating: postRating.rating,
          review: postRating.review,
          createdAt: postRating.createdAt,
          updatedAt: postRating.updatedAt,
        })
        .from(postRating)
        .innerJoin(post, eq(post.id, postRating.postId))
        .where(eq(post.status, "publish"))
        .orderBy(desc(postRating.createdAt))
        .limit(input.limit)
        .offset(input.offset);

      const userIds = [...new Set(ratings.map((r) => r.userId))];
      const postIds = [...new Set(ratings.map((r) => r.postId))];

      const authors =
        userIds.length > 0
          ? await db
              .select({
                id: user.id,
                name: user.name,
                image: user.image,
                role: user.role,
              })
              .from(user)
              .where(
                sql`${user.id} IN (${sql.join(
                  userIds.map((id) => sql`${id}`),
                  sql`, `
                )})`
              )
          : [];

      const posts =
        postIds.length > 0
          ? await db
              .select({
                id: post.id,
                title: post.title,
                type: post.type,
                imageObjectKeys: post.imageObjectKeys,
              })
              .from(post)
              .where(
                sql`${post.id} IN (${sql.join(
                  postIds.map((id) => sql`${id}`),
                  sql`, `
                )})`
              )
          : [];

      logger?.debug(
        `Retrieved ${ratings.length} recent ratings with ${authors.length} authors and ${posts.length} posts`
      );
      return { ratings, authors, posts };
    }),

  getByUserId: publicProcedure
    .input(
      z.object({
        userId: z.string(),
        limit: z.number().min(1).max(30).default(10),
        offset: z.number().min(0).default(0),
      })
    )
    .handler(async ({ context: { db, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(
        `Fetching ratings for user ${input.userId} with limit: ${input.limit}, offset: ${input.offset}`
      );

      const ratings = await db
        .select({
          postId: postRating.postId,
          rating: postRating.rating,
          review: postRating.review,
          createdAt: postRating.createdAt,
          updatedAt: postRating.updatedAt,
        })
        .from(postRating)
        .innerJoin(post, eq(post.id, postRating.postId))
        .where(
          and(eq(postRating.userId, input.userId), eq(post.status, "publish"))
        )
        .orderBy(desc(postRating.createdAt))
        .limit(input.limit)
        .offset(input.offset);

      const postIds = [...new Set(ratings.map((r) => r.postId))];

      const posts =
        postIds.length > 0
          ? await db
              .select({
                id: post.id,
                title: post.title,
                type: post.type,
                imageObjectKeys: post.imageObjectKeys,
              })
              .from(post)
              .where(
                sql`${post.id} IN (${sql.join(
                  postIds.map((id) => sql`${id}`),
                  sql`, `
                )})`
              )
          : [];

      logger?.debug(
        `Retrieved ${ratings.length} ratings with ${posts.length} posts for user ${input.userId}`
      );
      return { ratings, posts };
    }),

  // Get current user's rating for a post
  getUserRating: publicProcedure
    .input(z.object({ postId: z.string() }))
    .handler(async ({ context: { db, session, ...ctx }, input }) => {
      const logger = getLogger(ctx);

      if (!session?.user) {
        logger?.debug("User not authenticated, cannot fetch user rating");
        return null;
      }

      logger?.info(
        `Fetching user ${session.user.id} rating for post ${input.postId}`
      );

      const result = await db
        .select({
          postId: postRating.postId,
          userId: postRating.userId,
          rating: postRating.rating,
          review: postRating.review,
          createdAt: postRating.createdAt,
          updatedAt: postRating.updatedAt,
        })
        .from(postRating)
        .where(
          and(
            eq(postRating.postId, input.postId),
            eq(postRating.userId, session.user.id)
          )
        )
        .limit(1);

      if (result.length > 0) {
        logger?.debug(
          `Found rating for user ${session.user.id} on post ${input.postId}`
        );
      } else {
        logger?.debug(
          `No rating found for user ${session.user.id} on post ${input.postId}`
        );
      }

      return result[0] ?? null;
    }),

  // Get rating stats for a post (average and count)
  getStats: publicProcedure
    .input(z.object({ postId: z.string() }))
    .handler(async ({ context: { db, ...ctx }, input }) => {
      const logger = getLogger(ctx);
      logger?.info(`Fetching rating stats for post: ${input.postId}`);

      const result = await db
        .select({
          averageRating: sql<number>`COALESCE(AVG(${postRating.rating})::float, 0)`,
          ratingCount: sql<number>`COUNT(*)::integer`,
        })
        .from(postRating)
        .where(eq(postRating.postId, input.postId));

      const averageRating = result[0]?.averageRating ?? 0;
      const ratingCount = result[0]?.ratingCount ?? 0;

      logger?.debug(
        `Post ${input.postId} stats: avg=${averageRating.toFixed(2)}, count=${ratingCount}`
      );
      return {
        averageRating,
        ratingCount,
      };
    }),
};
