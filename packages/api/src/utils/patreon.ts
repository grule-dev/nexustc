import { createHmac } from "node:crypto";
import { env } from "@repo/env";
import { PatreonIdentity } from "@repo/patreon";
import {
  PATREON_TIER_MAPPING,
  PATRON_TIERS,
  type PatronTier,
} from "@repo/shared/constants";

export type PatreonTokenResponse = {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
};

export type PatreonMembership = {
  isActive: boolean;
  pledgeAmountCents: number;
  patronSince: string | null;
  entitledTierIds: string[];
};

/**
 * Refresh an expired Patreon access token using the refresh token.
 */
export async function refreshPatreonToken(
  refreshToken: string
): Promise<PatreonTokenResponse> {
  const response = await fetch("https://www.patreon.com/api/oauth2/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "refresh_token",
      refresh_token: refreshToken,
      client_id: env.PATREON_CLIENT_ID,
      client_secret: env.PATREON_CLIENT_SECRET,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to refresh Patreon token: ${error}`);
  }

  const data = (await response.json()) as {
    access_token: string;
    refresh_token: string;
    expires_in: number;
  };

  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    expiresIn: data.expires_in,
  };
}

/**
 * Fetch membership data for a user from the Patreon API.
 * Returns null if the user has no membership.
 */
export async function fetchPatreonMembership(
  accessToken: string,
  _campaignId: string
): Promise<PatreonMembership | null> {
  const patreonIdentity = new PatreonIdentity(accessToken);
  const [error, data, success] = await patreonIdentity.fetchIdentity();

  if (!success) {
    console.error("Error fetching Patreon identity:", error);
    throw new Error("Failed to fetch Patreon identity");
  }

  // Find the first membership (user should only have one to our campaign)
  const membership = data.included?.find((item) => item.type === "member");

  if (!membership) {
    return null;
  }

  const entitledTiers =
    membership.relationships?.currently_entitled_tiers?.data ?? [];

  return {
    isActive: membership.attributes?.patron_status === "active_patron",
    pledgeAmountCents:
      membership.attributes?.currently_entitled_amount_cents ?? 0,
    patronSince: membership.attributes?.pledge_relationship_start ?? null,
    entitledTierIds: entitledTiers.map((t) => t.id),
  };
}

/**
 * Determine the highest tier from a list of Patreon tier IDs.
 * Uses the PATREON_TIER_MAPPING to map external tier IDs to our internal tiers.
 */
export function determineTierFromIds(tierIds: string[]): PatronTier {
  let highestTier: PatronTier = "none";
  let highestLevel = 0;

  for (const tierId of tierIds) {
    const mappedTier = PATREON_TIER_MAPPING[tierId];
    if (mappedTier) {
      const tierConfig = PATRON_TIERS[mappedTier];
      if (tierConfig.level > highestLevel) {
        highestLevel = tierConfig.level;
        highestTier = mappedTier;
      }
    }
  }

  return highestTier;
}

/**
 * Verify a Patreon webhook signature.
 * Patreon uses HMAC-MD5 to sign webhook payloads.
 */
export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expected = createHmac("md5", secret).update(payload).digest("hex");
  return signature === expected;
}
