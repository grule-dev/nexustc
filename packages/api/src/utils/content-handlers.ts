import { DeleteObjectsCommand, PutObjectCommand } from "@aws-sdk/client-s3";
import { getLogger } from "@orpc/experimental-pino";
import { eq } from "@repo/db";
import { post, termPostRelation } from "@repo/db/schema/app";
import { generateId } from "@repo/db/utils";
import { env } from "@repo/env";
import type { contentCreateSchema } from "@repo/shared/schemas";
import type { z } from "zod";
import type { Context } from "../context";
import { optimizeImageToWebp } from "../utils/images";
import { getS3Client } from "../utils/s3";

type ContentInput = z.infer<typeof contentCreateSchema>;
type ContentEditInput = ContentInput & { id: string };

type HandlerParams<T> = {
  context: Context & { session: NonNullable<Context["session"]> };
  input: T;
  errors: {
    NOT_FOUND: () => Error;
    INTERNAL_SERVER_ERROR: () => Error;
  };
};

export async function createContent({
  context: { db, session, ...ctx },
  input,
  errors,
}: HandlerParams<ContentInput>) {
  const logger = getLogger(ctx);
  const contentType = input.type;
  logger?.info(
    `User ${session.user?.id} creating new ${contentType}: "${input.title}"`
  );

  logger?.debug(`Optimizing ${input.files?.length || 0} uploaded images`);
  const optimizedImages = await Promise.all(
    input.files?.map((file) => optimizeImageToWebp(file)) || []
  );
  logger?.debug(`Successfully optimized ${optimizedImages.length} images`);

  const successfulImageUploads: string[] = [];

  const deleteHangingImages = async () => {
    if (successfulImageUploads.length === 0) {
      return;
    }
    logger?.info("Deleting any successfully uploaded images");
    try {
      await getS3Client().send(
        new DeleteObjectsCommand({
          Bucket: env.R2_ASSETS_BUCKET_NAME,
          Delete: {
            Objects: successfulImageUploads.map((key) => ({ Key: key })),
            Quiet: false,
          },
        })
      );
      logger?.info("Cleaned up uploaded images after failure");
    } catch (error) {
      logger?.error(
        `[IMPORTANT] Failed to delete images with keys: ${successfulImageUploads.join(", ")}.`
      );
      logger?.error(error);
    }
  };

  try {
    const keys = await Promise.allSettled(
      optimizedImages.map(async (buffer) => {
        const objectKey = `images/${contentType}/${generateId()}.webp`;
        await getS3Client().send(
          new PutObjectCommand({
            Bucket: env.R2_ASSETS_BUCKET_NAME,
            Key: objectKey,
            Body: buffer,
            ContentType: "image/webp",
            ContentLength: buffer.byteLength,
          })
        );
        return objectKey;
      })
    );
    successfulImageUploads.push(
      ...keys
        .filter((result) => result.status === "fulfilled")
        .map((result) => result.value)
    );

    const rejected = keys.filter((r) => r.status === "rejected");
    if (rejected.length > 0) {
      for (const r of rejected) {
        logger?.debug(`Upload failed: ${r.reason}`);
      }
      throw new Error("Failed to upload some images to R2");
    }
  } catch (error) {
    logger?.error("Error uploading images to R2");
    logger?.error(error);
    await deleteHangingImages();
    throw errors.INTERNAL_SERVER_ERROR();
  }

  let createdPostId: string | undefined;

  try {
    await db.transaction(async (tx) => {
      logger?.info(`Starting transaction for ${contentType} creation`);

      const [postData] = await tx
        .insert(post)
        .values({
          title: input.title,
          type: input.type,
          content:
            input.type === "post" ? input.content : (input.content ?? ""),
          adsLinks:
            input.type === "post" ? input.adsLinks : (input.adsLinks ?? ""),
          premiumLinks:
            input.type === "post"
              ? input.premiumLinks
              : (input.premiumLinks ?? ""),
          version:
            input.type === "post" ? input.version : (input.version ?? ""),
          authorId: session.user?.id,
          authorContent: input.authorContent ?? "",
          status: input.documentStatus,
          imageObjectKeys: successfulImageUploads,
          views: 0,
          isWeekly: false,
        })
        .returning({ postId: post.id });

      if (!postData) {
        logger?.error(
          `Failed to create ${contentType} for user ${session.user?.id}`
        );
        return tx.rollback();
      }

      createdPostId = postData.postId;
      logger?.debug(`Created ${contentType} with ID: ${postData.postId}`);

      const termIds = (
        input.type === "post" ? input.platforms : (input.platforms ?? [])
      )
        .concat(input.tags, input.languages ?? [], [
          input.censorship,
          input.type === "post" ? input.engine : (input.engine ?? ""),
          input.type === "post" ? input.status : (input.status ?? ""),
          input.type === "post" ? input.graphics : (input.graphics ?? ""),
        ])
        .filter((term) => term !== "")
        .map((termId) => ({
          postId: postData.postId,
          termId,
        }));

      if (termIds.length > 0) {
        await tx.insert(termPostRelation).values(termIds);
        logger?.debug(
          `Inserted ${termIds.length} term relations for ${contentType} ${postData.postId}`
        );
      }

      logger?.info(
        `${contentType} successfully created with ID: ${postData.postId}`
      );
    });
  } catch (error) {
    await deleteHangingImages();
    logger?.error(
      `Transaction failed during ${contentType} creation: ${(error as Error).message}`
    );
    throw error;
  }

  if (!createdPostId) {
    throw errors.INTERNAL_SERVER_ERROR();
  }

  return createdPostId;
}

export async function editContent({
  context: { db, ...ctx },
  input,
  errors,
}: HandlerParams<ContentEditInput>) {
  const logger = getLogger(ctx);
  const contentType = input.type;
  logger?.info(`Editing ${contentType}: ${input.id}`);

  const [postData] = await db
    .update(post)
    .set({
      title: input.title,
      content: input.type === "post" ? input.content : (input.content ?? ""),
      status: input.documentStatus,
      version: input.type === "post" ? input.version : (input.version ?? ""),
      adsLinks: input.type === "post" ? input.adsLinks : (input.adsLinks ?? ""),
      premiumLinks:
        input.type === "post" ? input.premiumLinks : (input.premiumLinks ?? ""),
    })
    .where(eq(post.id, input.id))
    .returning({ postId: post.id });

  if (!postData) {
    logger?.error(`${contentType} not found for edit: ${input.id}`);
    throw errors.NOT_FOUND();
  }

  await db
    .delete(termPostRelation)
    .where(eq(termPostRelation.postId, postData.postId));

  const termIds = (
    input.type === "post" ? input.platforms : (input.platforms ?? [])
  )
    .concat(input.tags, input.languages ?? [], [
      input.censorship,
      input.type === "post" ? input.engine : (input.engine ?? ""),
      input.type === "post" ? input.status : (input.status ?? ""),
      input.type === "post" ? input.graphics : (input.graphics ?? ""),
    ])
    .filter((term) => term !== "")
    .map((termId) => ({
      postId: postData.postId,
      termId,
    }));

  if (termIds.length > 0) {
    await db.insert(termPostRelation).values(termIds);
    logger?.debug(
      `Updated ${termIds.length} term relations for ${contentType} ${postData.postId}`
    );
  }

  logger?.info(`${contentType} ${input.id} successfully updated`);
  return postData.postId;
}

export async function deleteContent({
  context: { db, ...ctx },
  input,
}: Omit<HandlerParams<string>, "errors">) {
  const logger = getLogger(ctx);
  logger?.info(`Deleting content: ${input}`);

  const currentPost = await db.query.post.findFirst({
    where: (p, { eq: equals }) => equals(p.id, input),
  });

  if (!currentPost) {
    logger?.warn(`Content not found for deletion: ${input}`);
    return;
  }

  await Promise.all([
    currentPost?.imageObjectKeys &&
      getS3Client().send(
        new DeleteObjectsCommand({
          Bucket: env.R2_ASSETS_BUCKET_NAME,
          Delete: {
            Objects: currentPost.imageObjectKeys.map((key) => ({
              Key: key,
            })),
          },
        })
      ),
    db.delete(post).where(eq(post.id, input)),
  ]);

  if (currentPost?.imageObjectKeys) {
    logger?.debug(
      `Deleted ${currentPost.imageObjectKeys.length} images for content ${input}`
    );
  }
  logger?.info(`Content ${input} successfully deleted`);
}

export async function insertContentImages({
  context: { db, ...ctx },
  input,
}: Omit<HandlerParams<{ postId: string; images: string[] }>, "errors">) {
  const logger = getLogger(ctx);
  logger?.info(
    `Inserting ${input.images.length} images for content: ${input.postId}`
  );

  await db
    .update(post)
    .set({
      imageObjectKeys: input.images,
    })
    .where(eq(post.id, input.postId));

  logger?.info(`Images successfully inserted for content ${input.postId}`);
}
